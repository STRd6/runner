<!DOCTYPE html>

<html>
<head>
  <title>package_runner</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="http://strd6.github.io/cdn/parallel/docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    <ul class="sections">
        
        
        <li id="section-1">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="package-runner">Package Runner</h1>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Run a package in an iframe.</p>
<p>The <code>launch</code> command will get the state of the app, replace the iframe with a clean
one, boot the new package and reload the app state. You can also optionally pass
in an app state to launch into.</p>
<p>A primary reason for wrapping the running iframe with a shim window is that we
can dispose of timeouts and everything else very cleanly, while still keeping the
same opened window.</p>
<p>One example use of hot reloading is if you are modifying your css you can run
several instances of your app and navigate to different states. Then you can see
in real time how the css changes affect each one.</p>
<p>The package runner assumes that it has total control over the document so you
probably won&#39;t want to give it the one in your own window.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">{extend} = require <span class="string">"util"</span>

Sandbox = require <span class="string">"./sandbox"</span>
Postmaster = require <span class="string">"postmaster"</span>

module.<span class="function"><span class="title">exports</span></span> = (config={}) -&gt;
  runningInstance = <span class="literal">null</span>

  externalWindow = <span class="literal">null</span>
  externalDocument = <span class="literal">null</span>

  self =
    popOut: -&gt;
      <span class="keyword">return</span> <span class="keyword">if</span> externalWindow

      externalWindow = Sandbox(config)
      externalDocument = externalWindow.document

      applyStylesheet externalDocument, require <span class="string">"./style"</span>

      <span class="comment"># TODO: Migrate data from existing state</span>

    remoteTarget: -&gt;
      runningInstance?.contentWindow

    launch: (pkg, data) -&gt;
      <span class="comment"># Get data from running instance</span>
      <span class="comment"># TODO: This won't work on remote urls,</span>
      <span class="comment"># need to use postMessage</span>
      data ?= runningInstance?.contentWindow?.appData?()

      <span class="comment"># Remove Running instance</span>
      runningInstance?.remove()

      <span class="comment"># Create new instance</span>
      runningInstance = document.createElement <span class="string">"iframe"</span>
      externalDocument.body.appendChild runningInstance

      proxyCalls externalWindow, runningInstance

      <span class="comment"># Pass in app state</span>
      extend runningInstance.contentWindow.ENV ?= {},
        APP_STATE: data

      runningInstance.contentWindow.document.write html(pkg)

      <span class="keyword">return</span> self

    close: -&gt;
      externalWindow.close()

    eval: (code) -&gt;
      runningInstance.contentWindow.eval(code)

  Postmaster(config, self)

  <span class="keyword">return</span> self</code></pre>
</div>
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>A standalone html page for a package.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">html = module.exports.<span class="function"><span class="title">html</span></span> = (pkg) -&gt;
  <span class="string">"""
    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
    &lt;head&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
    <span class="subst">#{dependencyScripts(pkg.remoteDependencies)}</span>
    &lt;/head&gt;
    &lt;body&gt;
    &lt;script&gt;
    <span class="subst">#{require('require').executePackageWrapper(pkg)}</span>
    &lt;\/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;
  """</span></code></pre>
</div>
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2 id="helpers">Helpers</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Proxy calls from the iframe to the top window. Currently just proxying logging,
but may add others as needed.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">proxyCalls</span></span> = (window, iframe) -&gt;
  [
    <span class="string">"opener"</span>
    <span class="string">"console"</span>
  ].forEach (name) -&gt;
    <span class="comment"># !!! Can't do this on remote urls</span>
    <span class="comment"># Either need to do a full postMessage proxy</span>
    <span class="comment"># or don't wrap remote windows, just let them be</span>
    iframe.contentWindow[name] = window[name]</code></pre>
</div>
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p><code>makeScript</code> returns a string representation of a script tag that has a src
attribute.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">makeScript</span></span> = (src) -&gt;
  <span class="string">"&lt;script src=<span class="subst">#{JSON.stringify(src)}</span>&gt;&lt;\/script&gt;"</span></code></pre>
</div>
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p><code>dependencyScripts</code> returns a string containing the script tags that are
the remote script dependencies of this build.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">dependencyScripts</span></span> = (remoteDependencies=[]) -&gt;
  remoteDependencies.map(makeScript).join(<span class="string">"\n"</span>)

<span class="function"><span class="title">applyStylesheet</span></span> = (document, style, id=<span class="string">"primary"</span>) -&gt;
  styleNode = document.createElement(<span class="string">"style"</span>)
  styleNode.innerHTML = style
  styleNode.id = id

  <span class="keyword">if</span> previousStyleNode = document.head.querySelector(<span class="string">"style#<span class="subst">#{id}</span>"</span>)
    previousStyleNode.parentNode.removeChild(prevousStyleNode)

  document.head.appendChild(styleNode)</code></pre>
</div>
        </li>
        
    </ul>
  </div>
  <script src="https://code.jquery.com/jquery-1.10.1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js"></script><script>
  (function() {
  var ErrorReporter, bindUpdates, createEditor, exec, findInteractiveElements, readShebang, runners;

  createEditor = function(code, shebang, section) {
    var annotationElement, contentElement, editorElement, exampleSection, runtimeElement;
    exampleSection = $("<li>", {
      "class": "example"
    });
    annotationElement = $("<div>", {
      "class": "annotation"
    });
    editorElement = $("<textarea>", {
      "class": "annotation",
      text: code
    });
    contentElement = $("<div>", {
      "class": "content"
    });
    runtimeElement = $("<div>", {
      "class": "output"
    });
    contentElement.append(runtimeElement);
    annotationElement.append(editorElement);
    exampleSection.append(annotationElement);
    exampleSection.append(contentElement);
    section.after(exampleSection);
    return bindUpdates(shebang, editorElement, runtimeElement);
  };

  bindUpdates = function(shebang, editorElement, runtimeElement) {
    return editorElement.on("keyup", function() {
      var e, report, source;
      report = ErrorReporter(editorElement);
      source = editorElement.val();
      try {
        runners[shebang]({
          editorElement: editorElement,
          source: source,
          runtimeElement: runtimeElement
        });
        return report.clear();
      } catch (_error) {
        e = _error;
        return report(e);
      }
    });
  };

  readShebang = function(source) {
    var match;
    if (match = source.match(/^\#\! (.*)\n/)) {
      return match[1];
    }
  };

  ErrorReporter = function(editor) {
    var reporter;
    reporter = function(error) {
      var errorParagraph;
      if (editor.next().is("p.error")) {
        return editor.next().text(error);
      } else {
        errorParagraph = $("<p>", {
          "class": "error",
          text: error.toString()
        });
        return editor.after(errorParagraph);
      }
    };
    reporter.clear = function() {
      if (editor.next().is("p.error")) {
        return editor.next().remove();
      }
    };
    return reporter;
  };

  findInteractiveElements = function() {
    return $("blockquote > pre > code").each(function() {
      var blockQuoteElement, code, codeElement, sectionElement, shebang;
      codeElement = $(this);
      code = codeElement.text();
      if (shebang = readShebang(code)) {
        if (!runners[shebang]) {
          return;
        }
        code = code.split("\n").slice(1).join("\n");
        blockQuoteElement = codeElement.parent().parent();
        sectionElement = blockQuoteElement.parent().parent();
        blockQuoteElement.remove();
        return createEditor(code, shebang, sectionElement);
      }
    });
  };

  runners = {};

  (typeof window !== "undefined" && window !== null ? window : global).Interactive = {
    register: function(name, runner) {
      runners[name] = runner;
      findInteractiveElements();
      return $('#container').on('keyup', 'textarea', function() {
        $(this).height(0);
        return $(this).height(this.scrollHeight);
      }).find('textarea').keyup();
    }
  };

  exec = function(_arg) {
    var code, editorElement, runtimeElement, source;
    source = _arg.source, code = _arg.code, editorElement = _arg.editorElement, runtimeElement = _arg.runtimeElement;
    runtimeElement.remove();
    editorElement.replaceWith($("<pre>", {
      text: source
    }));
    return setTimeout(function() {
      return Function(code)();
    }, 0);
  };

  $(function() {
    Interactive.register("setup", function(params) {
      params.code = CoffeeScript.compile(params.source);
      return exec(params);
    });
    return Interactive.register("setup-js", function(params) {
      params.code = params.source;
      return exec(params);
    });
  });

}).call(this);

</script><script src="package.js"></script>
</body>
</html>